{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation NPM Package yarn add molstar or npm install molstar Mol* code can then be imported from the molstar/lib/... namespace, e.g. import { PluginContext } from 'molstar/lib/mol-plugin/context' ; Clone from GitHub git clone https://github.com/molstar/molstar.git cd molstar npm install npm build For a watch task to automatically rebuild the source code on changes, run npm run watch or if working just with the Viewer app for better performance npm run watch-viewer","title":"Installation"},{"location":"#installation","text":"","title":"Installation"},{"location":"#npm-package","text":"yarn add molstar or npm install molstar Mol* code can then be imported from the molstar/lib/... namespace, e.g. import { PluginContext } from 'molstar/lib/mol-plugin/context' ;","title":"NPM Package"},{"location":"#clone-from-github","text":"git clone https://github.com/molstar/molstar.git cd molstar npm install npm build For a watch task to automatically rebuild the source code on changes, run npm run watch or if working just with the Viewer app for better performance npm run watch-viewer","title":"Clone from GitHub"},{"location":"data-state/","text":"Data State Management Managers State Tree, Selectors, Transforms State Snapshots Structure, Trajectory, Cell Ref, Representation","title":"Data State Management"},{"location":"data-state/#data-state-management","text":"","title":"Data State Management"},{"location":"data-state/#managers","text":"","title":"Managers"},{"location":"data-state/#state-tree-selectors-transforms","text":"","title":"State Tree, Selectors, Transforms"},{"location":"data-state/#state-snapshots","text":"","title":"State Snapshots"},{"location":"data-state/#structure-trajectory-cell","text":"","title":"Structure, Trajectory, Cell"},{"location":"data-state/#ref-representation","text":"","title":"Ref, Representation"},{"location":"examples/","text":"Examples Refer to Mol* Apps and Examples .","title":"Examples"},{"location":"examples/#examples","text":"Refer to Mol* Apps and Examples .","title":"Examples"},{"location":"plugin/","text":"Creating Plugin Instance Intro What is a plugin? A plugin is a collection of modules that provide functionality to the Mol* UI. The plugin is responsible for managing the state of the viewer, internal and user interactions. It has been a previous point of confusion for new users of Mol* to associate the viewer part of the library with what is further referred to as the plugin . These two are closely connected in the molstar-plugin-ui module, which is the user-facing part of the library and ultimately provides the viewer, but they are ultimately distinct. It is recommended that you inspect the general class structure of PluginInitWrapper , PluginUIContext and PluginUIComponent to better understand the flow of data and events in the plugin. A passing analogy is that a PluginContext is the engine that powers computation, rendering, events and subscriptions inside the molstar UI. All UI components depend on PluginContext . There are 4 basic ways of instantiating the Mol* plugin. Viewer wrapper The most basic usage is to use the Viewer wrapper. This is best suited for use cases that do not require much custom behavior and are mostly about just displaying a structure. See Viewer class is defined in src/apps/viewer/app.ts for available methods and options. Example usage without using WebPack: < style > # app { position : absolute ; left : 100 px ; top : 100 px ; width : 800 px ; height : 600 px ; } </ style > <!-- molstar.js and .css are obtained from - the folder build/viewer after cloning and building the molstar package - from the build/viewer folder in the Mol* NPM package --> < link rel = \"stylesheet\" type = \"text/css\" href = \"molstar.css\" /> < script type = \"text/javascript\" src = \"./molstar.js\" ></ script > < div id = \"app\" ></ div > < script type = \"text/javascript\" > molstar . Viewer . create ( 'app' , { layoutIsExpanded : false , layoutShowControls : false , layoutShowRemoteState : false , layoutShowSequence : true , layoutShowLog : false , layoutShowLeftPanel : true , viewportShowExpand : true , viewportShowSelectionMode : false , viewportShowAnimation : false , pdbProvider : 'rcsb' , emdbProvider : 'rcsb' , }). then ( viewer => { viewer . loadPdb ( '7bv2' ); viewer . loadEmdb ( 'EMD-30210' , { detail : 6 }); }); </ script > When using WebPack (or possibly other build tool) with the Mol* NPM package installed, the viewer class can be imported using import { Viewer } from 'molstar/build/viewer/molstar' function initViewer ( target : string | HTMLElement ) { return new Viewer ( target , { /* options */ }) } PluginContext with built-in React UI For more customization options it is possible to use the PluginContext directly. When creating the plugin instance it is possible to customize the PluginSpec . The default PluginSpec is available here . PluginConfig object provides additional customization options. See the Viewer State Management section for more information on customizing things like background. See the Data State Management section for more information on build the state. import { DefaultPluginUISpec , PluginUISpec } from 'molstar/lib/mol-plugin-ui/spec' ; import { createPluginUI } from 'molstar/lib/mol-plugin-ui' ; import { renderReact18 } from 'molstar/lib/mol-plugin-ui/react18' ; import { PluginConfig } from 'molstar/lib/mol-plugin/config' ; const MySpec : PluginUISpec = { ... DefaultPluginUISpec (), config : [ [ PluginConfig . VolumeStreaming . Enabled , false ] ] } async function createPlugin ( parent : HTMLElement ) { const plugin = await createPluginUI ({ target : parent , spec : MySpec , render : renderReact18 }); const data = await plugin . builders . data . download ({ url : '...' }, { state : { isGhost : true } }); const trajectory = await plugin . builders . structure . parseTrajectory ( data , format ); await this . plugin . builders . structure . hierarchy . applyPreset ( trajectory , 'default' ); return plugin ; } createPlugin ( document . getElementById ( 'app' ) ! ); // app is a <div> element with position: relative To use the plugin (with the React UI) inside another React app: A single-plugin setup is shown the example below. In order to initialize multiple plugins, each with its own context and viewport, some extra steps are required (docs section to be added). import { useEffect , createRef } from \"react\" ; import { createPluginUI } from \"molstar/lib/mol-plugin-ui\" ; import { renderReact18 } from \"molstar/lib/mol-plugin-ui/react18\" ; import { PluginUIContext } from \"molstar/lib/mol-plugin-ui/context\" ; /* Might require extra configuration, see https://webpack.js.org/loaders/sass-loader/ for example. create-react-app should support this natively. */ import \"molstar/lib/mol-plugin-ui/skin/light.scss\" ; declare global { interface Window { molstar? : PluginUIContext ; } } export function MolStarWrapper () { const parent = createRef < HTMLDivElement > (); // In debug mode of react's strict mode, this code will // be called twice in a row, which might result in unexpected behavior. useEffect (() => { async function init () { window . molstar = await createPluginUI ({ target : parent.current as HTMLDivElement , render : renderReact18 }); const data = await window . molstar . builders . data . download ( { url : \"https://files.rcsb.org/download/3PTB.pdb\" }, /* replace with your URL */ { state : { isGhost : true } } ); const trajectory = await window . molstar . builders . structure . parseTrajectory ( data , \"pdb\" ); await window . molstar . builders . structure . hierarchy . applyPreset ( trajectory , \"default\" ); } init (); return () => { window . molstar ? . dispose (); window . molstar = undefined ; }; }, []); return < div ref = { parent } style = {{ width : 640 , height : 480 }} /> ; } Furthermore, if it is desirable in your project to use the molstar 's React UI components, but you wish to alter or rearrange the layout, you should take a look at the signatures of PluginUIComponent which every \"control\" subclasses. SequenceView , for example, can be used separately from the PluginUI . Yet you would need to pass the PluginUIContext to it in order for it to observe the changes in the state of the plugin. This can be done via a PluginContextContainer : // your_app.plugin: PluginUIContext ... < div className = \"your_custom_ui\" > < PluginContextContainer plugin = { your_app . plugin } > < SequenceView /> < /PluginContextContainer> < /div> Directly using Mol* React UI class MolStarWrapper { private resolveInit : () => void ; initialized = new Promise < boolean > ( res => { this . resolveInit = () => res ( true ); }); private initCalled = false ; plugin : PluginUIContext ; async init () { if ( this . initCalled ) return ; this . initCalled = true ; this . plugin = ...; await this . plugin . init (); this . resolveInit (); } } function MolStar ({ model } : { model : MolStarWrapper }) { const [ initialized , setInitialized ] = useState ( false ); useEffect (() => { async function init () { await model . init (); setInitialized ( true ); } init (); }, [ model ]); if ( ! initialized ) return <> Loading < />; return < div style = {{ ..., position : 'relative' }} > < Plugin plugin = { model . plugin } /> < /div>; } PluginContext without built-in React UI The PluginContext can be instantiated without using the default React UI. < div id = 'molstar-parent' style = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0' > < canvas id = 'molstar-canvas' style = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0' ></ canvas > </ div > import { DefaultPluginSpec , PluginSpec } from 'molstar/lib/mol-plugin/spec' ; import { PluginContext } from 'molstar/lib/mol-plugin/context' ; import { PluginConfig } from 'molstar/lib/mol-plugin/config' ; const MySpec : PluginSpec = { ... DefaultPluginSpec (), config : [ [ PluginConfig . VolumeStreaming . Enabled , false ] ] } async function init () { const plugin = new PluginContext ( MySpec ); await plugin . init (); const canvas = < HTMLCanvasElement > document . getElementById ( 'molstar-canvas' ); const parent = < HTMLDivElement > document . getElementById ( 'molstar-parent' ); if ( ! plugin . initViewer ( canvas , parent )) { console . error ( 'Failed to init Mol*' ); return ; } // Example url:\"https://files.rcsb.org/download/3j7z.pdb\" // Example url:\"https://files.rcsb.org/download/5AFI.cif\" const data = await plugin . builders . data . download ({ url : '...' }, { state : { isGhost : true } }); const trajectory = await plugin . builders . structure . parseTrajectory ( data , format ); //format is 'mmcif' or 'pdb' etc. await plugin . builders . structure . hierarchy . applyPreset ( trajectory , 'default' ); } Canvas3D without built-in state management The PluginContext object from the above examples can be completely omitted. See Browser Tests for example usage. const canvas = document . getElementById ( 'canvas' ); // parent <canvas> element const canvas3d = Canvas3D . create ( Canvas3DContext . fromCanvas ( canvas )); canvas3d . animate (); // use the canvas3d object here","title":"Creating Plugin Instance"},{"location":"plugin/#creating-plugin-instance","text":"","title":"Creating Plugin Instance"},{"location":"plugin/#intro","text":"What is a plugin? A plugin is a collection of modules that provide functionality to the Mol* UI. The plugin is responsible for managing the state of the viewer, internal and user interactions. It has been a previous point of confusion for new users of Mol* to associate the viewer part of the library with what is further referred to as the plugin . These two are closely connected in the molstar-plugin-ui module, which is the user-facing part of the library and ultimately provides the viewer, but they are ultimately distinct. It is recommended that you inspect the general class structure of PluginInitWrapper , PluginUIContext and PluginUIComponent to better understand the flow of data and events in the plugin. A passing analogy is that a PluginContext is the engine that powers computation, rendering, events and subscriptions inside the molstar UI. All UI components depend on PluginContext . There are 4 basic ways of instantiating the Mol* plugin.","title":"Intro"},{"location":"plugin/#viewer-wrapper","text":"The most basic usage is to use the Viewer wrapper. This is best suited for use cases that do not require much custom behavior and are mostly about just displaying a structure. See Viewer class is defined in src/apps/viewer/app.ts for available methods and options. Example usage without using WebPack: < style > # app { position : absolute ; left : 100 px ; top : 100 px ; width : 800 px ; height : 600 px ; } </ style > <!-- molstar.js and .css are obtained from - the folder build/viewer after cloning and building the molstar package - from the build/viewer folder in the Mol* NPM package --> < link rel = \"stylesheet\" type = \"text/css\" href = \"molstar.css\" /> < script type = \"text/javascript\" src = \"./molstar.js\" ></ script > < div id = \"app\" ></ div > < script type = \"text/javascript\" > molstar . Viewer . create ( 'app' , { layoutIsExpanded : false , layoutShowControls : false , layoutShowRemoteState : false , layoutShowSequence : true , layoutShowLog : false , layoutShowLeftPanel : true , viewportShowExpand : true , viewportShowSelectionMode : false , viewportShowAnimation : false , pdbProvider : 'rcsb' , emdbProvider : 'rcsb' , }). then ( viewer => { viewer . loadPdb ( '7bv2' ); viewer . loadEmdb ( 'EMD-30210' , { detail : 6 }); }); </ script > When using WebPack (or possibly other build tool) with the Mol* NPM package installed, the viewer class can be imported using import { Viewer } from 'molstar/build/viewer/molstar' function initViewer ( target : string | HTMLElement ) { return new Viewer ( target , { /* options */ }) }","title":"Viewer wrapper"},{"location":"plugin/#plugincontext-with-built-in-react-ui","text":"For more customization options it is possible to use the PluginContext directly. When creating the plugin instance it is possible to customize the PluginSpec . The default PluginSpec is available here . PluginConfig object provides additional customization options. See the Viewer State Management section for more information on customizing things like background. See the Data State Management section for more information on build the state. import { DefaultPluginUISpec , PluginUISpec } from 'molstar/lib/mol-plugin-ui/spec' ; import { createPluginUI } from 'molstar/lib/mol-plugin-ui' ; import { renderReact18 } from 'molstar/lib/mol-plugin-ui/react18' ; import { PluginConfig } from 'molstar/lib/mol-plugin/config' ; const MySpec : PluginUISpec = { ... DefaultPluginUISpec (), config : [ [ PluginConfig . VolumeStreaming . Enabled , false ] ] } async function createPlugin ( parent : HTMLElement ) { const plugin = await createPluginUI ({ target : parent , spec : MySpec , render : renderReact18 }); const data = await plugin . builders . data . download ({ url : '...' }, { state : { isGhost : true } }); const trajectory = await plugin . builders . structure . parseTrajectory ( data , format ); await this . plugin . builders . structure . hierarchy . applyPreset ( trajectory , 'default' ); return plugin ; } createPlugin ( document . getElementById ( 'app' ) ! ); // app is a <div> element with position: relative To use the plugin (with the React UI) inside another React app: A single-plugin setup is shown the example below. In order to initialize multiple plugins, each with its own context and viewport, some extra steps are required (docs section to be added). import { useEffect , createRef } from \"react\" ; import { createPluginUI } from \"molstar/lib/mol-plugin-ui\" ; import { renderReact18 } from \"molstar/lib/mol-plugin-ui/react18\" ; import { PluginUIContext } from \"molstar/lib/mol-plugin-ui/context\" ; /* Might require extra configuration, see https://webpack.js.org/loaders/sass-loader/ for example. create-react-app should support this natively. */ import \"molstar/lib/mol-plugin-ui/skin/light.scss\" ; declare global { interface Window { molstar? : PluginUIContext ; } } export function MolStarWrapper () { const parent = createRef < HTMLDivElement > (); // In debug mode of react's strict mode, this code will // be called twice in a row, which might result in unexpected behavior. useEffect (() => { async function init () { window . molstar = await createPluginUI ({ target : parent.current as HTMLDivElement , render : renderReact18 }); const data = await window . molstar . builders . data . download ( { url : \"https://files.rcsb.org/download/3PTB.pdb\" }, /* replace with your URL */ { state : { isGhost : true } } ); const trajectory = await window . molstar . builders . structure . parseTrajectory ( data , \"pdb\" ); await window . molstar . builders . structure . hierarchy . applyPreset ( trajectory , \"default\" ); } init (); return () => { window . molstar ? . dispose (); window . molstar = undefined ; }; }, []); return < div ref = { parent } style = {{ width : 640 , height : 480 }} /> ; } Furthermore, if it is desirable in your project to use the molstar 's React UI components, but you wish to alter or rearrange the layout, you should take a look at the signatures of PluginUIComponent which every \"control\" subclasses. SequenceView , for example, can be used separately from the PluginUI . Yet you would need to pass the PluginUIContext to it in order for it to observe the changes in the state of the plugin. This can be done via a PluginContextContainer : // your_app.plugin: PluginUIContext ... < div className = \"your_custom_ui\" > < PluginContextContainer plugin = { your_app . plugin } > < SequenceView /> < /PluginContextContainer> < /div>","title":"PluginContext with built-in React UI"},{"location":"plugin/#directly-using-mol-react-ui","text":"class MolStarWrapper { private resolveInit : () => void ; initialized = new Promise < boolean > ( res => { this . resolveInit = () => res ( true ); }); private initCalled = false ; plugin : PluginUIContext ; async init () { if ( this . initCalled ) return ; this . initCalled = true ; this . plugin = ...; await this . plugin . init (); this . resolveInit (); } } function MolStar ({ model } : { model : MolStarWrapper }) { const [ initialized , setInitialized ] = useState ( false ); useEffect (() => { async function init () { await model . init (); setInitialized ( true ); } init (); }, [ model ]); if ( ! initialized ) return <> Loading < />; return < div style = {{ ..., position : 'relative' }} > < Plugin plugin = { model . plugin } /> < /div>; }","title":"Directly using Mol* React UI"},{"location":"plugin/#plugincontext-without-built-in-react-ui","text":"The PluginContext can be instantiated without using the default React UI. < div id = 'molstar-parent' style = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0' > < canvas id = 'molstar-canvas' style = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0' ></ canvas > </ div > import { DefaultPluginSpec , PluginSpec } from 'molstar/lib/mol-plugin/spec' ; import { PluginContext } from 'molstar/lib/mol-plugin/context' ; import { PluginConfig } from 'molstar/lib/mol-plugin/config' ; const MySpec : PluginSpec = { ... DefaultPluginSpec (), config : [ [ PluginConfig . VolumeStreaming . Enabled , false ] ] } async function init () { const plugin = new PluginContext ( MySpec ); await plugin . init (); const canvas = < HTMLCanvasElement > document . getElementById ( 'molstar-canvas' ); const parent = < HTMLDivElement > document . getElementById ( 'molstar-parent' ); if ( ! plugin . initViewer ( canvas , parent )) { console . error ( 'Failed to init Mol*' ); return ; } // Example url:\"https://files.rcsb.org/download/3j7z.pdb\" // Example url:\"https://files.rcsb.org/download/5AFI.cif\" const data = await plugin . builders . data . download ({ url : '...' }, { state : { isGhost : true } }); const trajectory = await plugin . builders . structure . parseTrajectory ( data , format ); //format is 'mmcif' or 'pdb' etc. await plugin . builders . structure . hierarchy . applyPreset ( trajectory , 'default' ); }","title":"PluginContext without built-in React UI"},{"location":"plugin/#canvas3d-without-built-in-state-management","text":"The PluginContext object from the above examples can be completely omitted. See Browser Tests for example usage. const canvas = document . getElementById ( 'canvas' ); // parent <canvas> element const canvas3d = Canvas3D . create ( Canvas3DContext . fromCanvas ( canvas )); canvas3d . animate (); // use the canvas3d object here","title":"Canvas3D without built-in state management"},{"location":"selections/","text":"Selections Assuming you have a model already loaded into the plugin (see initiation ), these are some of the following method you can select structural data. Selecting directly from the hierarchy manager One can select a subcomponent's data directly from the plugin manager. import { Structure } from '../mol-model/structure' ; const ligandData = plugin . managers . structure . hierarchy . selection . structures [ 0 ] ? . components [ 0 ] ? . cell . obj ? . data ; const ligandLoci = Structure . toStructureElementLoci ( ligandData as any ); plugin . managers . camera . focusLoci ( ligandLoci ); plugin . managers . interactivity . lociSelects . select ({ loci : ligandLoci }); Selection callbacks If you want to subscribe to selection events (e.g. to change external state in your application based on a user selection), you can use: plugin.behaviors.interaction.click.subscribe Here's an example of passing in a React \"set\" function to update selected residue positions. import { Structure , StructureProperties , } from \"molstar/lib/mol-model/structure\" // setSelected is assumed to be a \"set\" function returned by useState // (selected: any[]) => void plugin . behaviors . interaction . click . subscribe ( ( event : InteractivityManager.ClickEvent ) => { const selections = Array . from ( plugin . managers . structure . selection . entries . values () ); // This bit can be customized to record any piece information you want const localSelected : any [] = []; for ( const { structure } of selections ) { if ( ! structure ) continue ; Structure . eachAtomicHierarchyElement ( structure , { residue : ( loc ) => { const position = StructureProperties . residue . label_seq_id ( loc ); localSelected . push ({ position }); }, }); } setSelected ( localSelected ); } ) Molscript language Molscript is a language for addressing crystallographic structures and is a part of the Mol* library found at https://github.com/molstar/molstar/tree/master/src/mol-script . It can be used against the Molstar plugin as a query language and traspiled against multiple external molecular visualization libraries(see here ). Querying a structure for a specific chain and residue range (select residues with 12<res_id<200 of chain with auth_asym_id==A) : import { compileIdListSelection } from 'molstar/lib/mol-script/util/id-list' const query = compileIdListSelection ( 'A 12-200' , 'auth' ); window . molstar ? . managers . structure . selection . fromCompiledQuery ( 'add' , query ); Selection Queries Another way to create a selection is via a SelectionQuery object. This is a more programmatic way to create a selection. The following example shows how to select a chain and a residue range using a SelectionQuery object. This relies on the concept of Expression which is basically a intermediate representation between a Molscript statement and a selection query. Select residues 10-15 of chains A and F in a structure using a SelectionQuery object: import { MolScriptBuilder as MS , MolScriptBuilder } from 'molstar/lib/mol-script/language/builder' ; import { Expression } from 'molstar/lib/mol-script/language/expression' ; import { StructureSelectionQuery } from 'molstar/lib/mol-plugin-state/helpers/structure-selection-query' export function select_multiple () { const args = [[ 'A' , 10 , 15 ], [ 'F' , 10 , 15 ]] const groups : Expression [] = []; for ( var chain of args ) { groups . push ( MS . struct . generator . atomGroups ({ \"chain-test\" : MS . core . rel . eq ([ MolScriptBuilder . struct . atomProperty . macromolecular . auth_asym_id (), chain [ 0 ]]), \"residue-test\" : MS . core . rel . inRange ([ MolScriptBuilder . struct . atomProperty . macromolecular . label_seq_id (), chain [ 1 ], chain [ 2 ]]) })); } var sq = StructureSelectionQuery ( 'residue_range_10_15_in_A_and_F' , MS . struct . combinator . merge ( groups )) mstar . managers . structure . selection . fromSelectionQuery ( 'set' , sq ) } Complex queries can be constructed by combining primitive queries at the level of [ chain-test , residue-test , entity-test , etc] (https://github.com/molstar/molstar/blob/6edbae80db340134341631f669eec86543a0f1a8/src/mol-script/language/symbol-table/structure-query.ts#L88C4-L94C112) by combining them via logical connectives provided in the MolscriptBuilder.core.rel as above. Inspect these examples to get a better feeling for this syntax: https://github.com/molstar/molstar/blob/6edbae80db340134341631f669eec86543a0f1a8/src/mol-plugin-state/helpers/structure-selection-query.ts#L88-L580 Furthermore, a query made this way can be converted to a Loci object which is important in many parts of the libary: // Select residue 124 of chain A and convert to Loci const Q = MolScriptBuilder ; var sel = Script . getStructureSelection ( Q => Q . struct . generator . atomGroups ({ 'chain-test' : Q . core . rel . eq ([ Q . struct . atomProperty . macromolecular . auth_asym_id (), A ]), \"residue-test\" : Q . core . rel . eq ([ Q . struct . atomProperty . macromolecular . label_seq_id (), 124 ]), }), objdata ) let loci = StructureSelection . toLociWithSourceUnits ( sel );","title":"Selections"},{"location":"selections/#selections","text":"Assuming you have a model already loaded into the plugin (see initiation ), these are some of the following method you can select structural data.","title":"Selections"},{"location":"selections/#selecting-directly-from-the-hierarchy-manager","text":"One can select a subcomponent's data directly from the plugin manager. import { Structure } from '../mol-model/structure' ; const ligandData = plugin . managers . structure . hierarchy . selection . structures [ 0 ] ? . components [ 0 ] ? . cell . obj ? . data ; const ligandLoci = Structure . toStructureElementLoci ( ligandData as any ); plugin . managers . camera . focusLoci ( ligandLoci ); plugin . managers . interactivity . lociSelects . select ({ loci : ligandLoci });","title":"Selecting directly from the hierarchy manager"},{"location":"selections/#selection-callbacks","text":"If you want to subscribe to selection events (e.g. to change external state in your application based on a user selection), you can use: plugin.behaviors.interaction.click.subscribe Here's an example of passing in a React \"set\" function to update selected residue positions. import { Structure , StructureProperties , } from \"molstar/lib/mol-model/structure\" // setSelected is assumed to be a \"set\" function returned by useState // (selected: any[]) => void plugin . behaviors . interaction . click . subscribe ( ( event : InteractivityManager.ClickEvent ) => { const selections = Array . from ( plugin . managers . structure . selection . entries . values () ); // This bit can be customized to record any piece information you want const localSelected : any [] = []; for ( const { structure } of selections ) { if ( ! structure ) continue ; Structure . eachAtomicHierarchyElement ( structure , { residue : ( loc ) => { const position = StructureProperties . residue . label_seq_id ( loc ); localSelected . push ({ position }); }, }); } setSelected ( localSelected ); } )","title":"Selection callbacks"},{"location":"selections/#molscript-language","text":"Molscript is a language for addressing crystallographic structures and is a part of the Mol* library found at https://github.com/molstar/molstar/tree/master/src/mol-script . It can be used against the Molstar plugin as a query language and traspiled against multiple external molecular visualization libraries(see here ).","title":"Molscript language"},{"location":"selections/#querying-a-structure-for-a-specific-chain-and-residue-range-select-residues-with-12res_id200-of-chain-with-auth_asym_ida","text":"import { compileIdListSelection } from 'molstar/lib/mol-script/util/id-list' const query = compileIdListSelection ( 'A 12-200' , 'auth' ); window . molstar ? . managers . structure . selection . fromCompiledQuery ( 'add' , query );","title":"Querying a structure for a specific chain and residue range (select residues with 12&lt;res_id&lt;200 of chain with auth_asym_id==A) :"},{"location":"selections/#selection-queries","text":"Another way to create a selection is via a SelectionQuery object. This is a more programmatic way to create a selection. The following example shows how to select a chain and a residue range using a SelectionQuery object. This relies on the concept of Expression which is basically a intermediate representation between a Molscript statement and a selection query.","title":"Selection Queries"},{"location":"selections/#select-residues-10-15-of-chains-a-and-f-in-a-structure-using-a-selectionquery-object","text":"import { MolScriptBuilder as MS , MolScriptBuilder } from 'molstar/lib/mol-script/language/builder' ; import { Expression } from 'molstar/lib/mol-script/language/expression' ; import { StructureSelectionQuery } from 'molstar/lib/mol-plugin-state/helpers/structure-selection-query' export function select_multiple () { const args = [[ 'A' , 10 , 15 ], [ 'F' , 10 , 15 ]] const groups : Expression [] = []; for ( var chain of args ) { groups . push ( MS . struct . generator . atomGroups ({ \"chain-test\" : MS . core . rel . eq ([ MolScriptBuilder . struct . atomProperty . macromolecular . auth_asym_id (), chain [ 0 ]]), \"residue-test\" : MS . core . rel . inRange ([ MolScriptBuilder . struct . atomProperty . macromolecular . label_seq_id (), chain [ 1 ], chain [ 2 ]]) })); } var sq = StructureSelectionQuery ( 'residue_range_10_15_in_A_and_F' , MS . struct . combinator . merge ( groups )) mstar . managers . structure . selection . fromSelectionQuery ( 'set' , sq ) } Complex queries can be constructed by combining primitive queries at the level of [ chain-test , residue-test , entity-test , etc] (https://github.com/molstar/molstar/blob/6edbae80db340134341631f669eec86543a0f1a8/src/mol-script/language/symbol-table/structure-query.ts#L88C4-L94C112) by combining them via logical connectives provided in the MolscriptBuilder.core.rel as above. Inspect these examples to get a better feeling for this syntax: https://github.com/molstar/molstar/blob/6edbae80db340134341631f669eec86543a0f1a8/src/mol-plugin-state/helpers/structure-selection-query.ts#L88-L580 Furthermore, a query made this way can be converted to a Loci object which is important in many parts of the libary: // Select residue 124 of chain A and convert to Loci const Q = MolScriptBuilder ; var sel = Script . getStructureSelection ( Q => Q . struct . generator . atomGroups ({ 'chain-test' : Q . core . rel . eq ([ Q . struct . atomProperty . macromolecular . auth_asym_id (), A ]), \"residue-test\" : Q . core . rel . eq ([ Q . struct . atomProperty . macromolecular . label_seq_id (), 124 ]), }), objdata ) let loci = StructureSelection . toLociWithSourceUnits ( sel );","title":"Select residues 10-15 of chains A and F in a structure using a SelectionQuery object:"},{"location":"viewer-state/","text":"Viewer State Management Canvas3D Properties Properties of the Canvas3D can be changed using PluginCommands . Change background, highlight, or select color import { ColorNames } from 'molstar/lib/mol-util/color/names' ; import { PluginCommands } from 'molstar/lib/mol-plugin/commands' ; const renderer = plugin . canvas3d ! . props . renderer ; PluginCommands . Canvas3D . SetSettings ( plugin , { settings : { renderer : { ... renderer , backgroundColor : ColorNames.red /* or: 0xff0000 as Color */ } } }); Similarly, highlightColor and selectColor can be updated. Interactivity Interactivity in Mol* is based on the concept of Loci . A Loci usually references a collection of objects and can be created by a Selection . For example, the Loci captures all atoms in the chain with label_asym_id B of a protein: import { Script } from 'molstar/lib/mol-script/script' ; import { StructureSelection } from 'molstar/lib/mol-model/structure/query' ; const data = plugin . managers . structure . hierarchy . current . structures [ 0 ] ? . cell . obj ? . data ; if ( ! data ) return ; const selection = Script . getStructureSelection ( Q => Q . struct . generator . atomGroups ({ 'chain-test' : Q . core . rel . eq ([ 'B' , Q . ammp ( 'label_asym_id' )]) }), data ); const loci = StructureSelection . toLociWithSourceUnits ( selection ); A Loci can be used to trigger custom Behaviors . Log message to Mol* console The built-in console in the bottom center of the plugin shows log entries. plugin . log . message ( 'This message will appear in the Mol* console' ); Other log levels are: info , warn , and error . Show toast message Toast messages will appear in the bottom right of the plugin and will linger for a limited time before disappearing. import { PluginCommands } from 'molstar/lib/mol-plugin/commands' ; PluginCommands . Toast . Show ( plugin , { title : 'Custom Message' , message : 'A custom toast message that will disappear after 2 seconds.' , key : 'toast-custom' , timeoutMs : 2000 }); Behaviors The state of the Mol* plugin is usually governed by dynamic behaviors which can be set up in initial plugin specification or updated during the plugin runtime. This allows for high modularity and customizability of individual plugin instances. Highlight Loci Highlighting adds a transient overpaint to a representation that will linger until the mouse enters hovers over another object. Highlights can be applied to a previously defined Loci by: plugin . managers . interactivity . lociHighlights . highlightOnly ({ loci }); // loci: Loci Reset all highlights by: plugin . managers . interactivity . clearHighlights (); Select Loci Selected elements will appear with distinct visuals and, if applicable, the corresponding sequence positions will be shown in the Sequence Viewer panel. Selections persist until removed, for example by clicking the background. A Loci is selected by: plugin . managers . interactivity . lociSelects . select ({ loci }); // loci: Loci Deselect a specific Loci by: plugin . managers . interactivity . lociSelects . deselect ({ loci }); // loci: Loci To deselect everything: plugin . managers . interactivity . lociSelects . deselectAll (); Focus Loci The focus representation shows a Loci in ball-and-stick representation and, additionally, visualizes non-covalent interactions between atoms of the Loci as well as interactions with surrounding residues (default: 5 \u00c5). plugin . managers . structure . focus . setFromLoci ( loci ); Extend an existing focus representation by: plugin . managers . structure . focus . addFromLoci ( loci ); // loci: Loci Reset by: plugin . managers . structure . focus . clear (); Zoom Loci A Loci can also be used to manipulate the camera. Zoom in by: plugin . managers . camera . focusLoci ( loci ); // loci: Loci Restore the default camera position by: plugin . managers . camera . reset (); Turn off view resetting on new representations A new representation via something like . apply ( StateTransforms . Representation . VolumeRepresentation3D , ...) can reset the view to make the whole representation visible. When one wants to keep the view the same instead of having the rep reset the view, keep the view constant by: plugin . canvas3d ? . setProps ({ camera : { manualReset : true } });","title":"Viewer State Management"},{"location":"viewer-state/#viewer-state-management","text":"","title":"Viewer State Management"},{"location":"viewer-state/#canvas3d-properties","text":"Properties of the Canvas3D can be changed using PluginCommands .","title":"Canvas3D Properties"},{"location":"viewer-state/#change-background-highlight-or-select-color","text":"import { ColorNames } from 'molstar/lib/mol-util/color/names' ; import { PluginCommands } from 'molstar/lib/mol-plugin/commands' ; const renderer = plugin . canvas3d ! . props . renderer ; PluginCommands . Canvas3D . SetSettings ( plugin , { settings : { renderer : { ... renderer , backgroundColor : ColorNames.red /* or: 0xff0000 as Color */ } } }); Similarly, highlightColor and selectColor can be updated.","title":"Change background, highlight, or select color"},{"location":"viewer-state/#interactivity","text":"Interactivity in Mol* is based on the concept of Loci . A Loci usually references a collection of objects and can be created by a Selection . For example, the Loci captures all atoms in the chain with label_asym_id B of a protein: import { Script } from 'molstar/lib/mol-script/script' ; import { StructureSelection } from 'molstar/lib/mol-model/structure/query' ; const data = plugin . managers . structure . hierarchy . current . structures [ 0 ] ? . cell . obj ? . data ; if ( ! data ) return ; const selection = Script . getStructureSelection ( Q => Q . struct . generator . atomGroups ({ 'chain-test' : Q . core . rel . eq ([ 'B' , Q . ammp ( 'label_asym_id' )]) }), data ); const loci = StructureSelection . toLociWithSourceUnits ( selection ); A Loci can be used to trigger custom Behaviors .","title":"Interactivity"},{"location":"viewer-state/#log-message-to-mol-console","text":"The built-in console in the bottom center of the plugin shows log entries. plugin . log . message ( 'This message will appear in the Mol* console' ); Other log levels are: info , warn , and error .","title":"Log message to Mol* console"},{"location":"viewer-state/#show-toast-message","text":"Toast messages will appear in the bottom right of the plugin and will linger for a limited time before disappearing. import { PluginCommands } from 'molstar/lib/mol-plugin/commands' ; PluginCommands . Toast . Show ( plugin , { title : 'Custom Message' , message : 'A custom toast message that will disappear after 2 seconds.' , key : 'toast-custom' , timeoutMs : 2000 });","title":"Show toast message"},{"location":"viewer-state/#behaviors","text":"The state of the Mol* plugin is usually governed by dynamic behaviors which can be set up in initial plugin specification or updated during the plugin runtime. This allows for high modularity and customizability of individual plugin instances.","title":"Behaviors"},{"location":"viewer-state/#highlight-loci","text":"Highlighting adds a transient overpaint to a representation that will linger until the mouse enters hovers over another object. Highlights can be applied to a previously defined Loci by: plugin . managers . interactivity . lociHighlights . highlightOnly ({ loci }); // loci: Loci Reset all highlights by: plugin . managers . interactivity . clearHighlights ();","title":"Highlight Loci"},{"location":"viewer-state/#select-loci","text":"Selected elements will appear with distinct visuals and, if applicable, the corresponding sequence positions will be shown in the Sequence Viewer panel. Selections persist until removed, for example by clicking the background. A Loci is selected by: plugin . managers . interactivity . lociSelects . select ({ loci }); // loci: Loci Deselect a specific Loci by: plugin . managers . interactivity . lociSelects . deselect ({ loci }); // loci: Loci To deselect everything: plugin . managers . interactivity . lociSelects . deselectAll ();","title":"Select Loci"},{"location":"viewer-state/#focus-loci","text":"The focus representation shows a Loci in ball-and-stick representation and, additionally, visualizes non-covalent interactions between atoms of the Loci as well as interactions with surrounding residues (default: 5 \u00c5). plugin . managers . structure . focus . setFromLoci ( loci ); Extend an existing focus representation by: plugin . managers . structure . focus . addFromLoci ( loci ); // loci: Loci Reset by: plugin . managers . structure . focus . clear ();","title":"Focus Loci"},{"location":"viewer-state/#zoom-loci","text":"A Loci can also be used to manipulate the camera. Zoom in by: plugin . managers . camera . focusLoci ( loci ); // loci: Loci Restore the default camera position by: plugin . managers . camera . reset ();","title":"Zoom Loci"},{"location":"viewer-state/#turn-off-view-resetting-on-new-representations","text":"A new representation via something like . apply ( StateTransforms . Representation . VolumeRepresentation3D , ...) can reset the view to make the whole representation visible. When one wants to keep the view the same instead of having the rep reset the view, keep the view constant by: plugin . canvas3d ? . setProps ({ camera : { manualReset : true } });","title":"Turn off view resetting on new representations"},{"location":"data-access-tools/convert-to-bcif/","text":"Convert CIF to BinaryCIF BinaryCIF is an efficient, binary flavor of the CIF format. See specification and publication for further details. This script reads data in CIF format and converts it lossless to a BinaryCIF file that can be read by Mol* or other applications. Example node lib/commonjs/cli/cif2bcif/index.js file.cif file.bcif Usage Argument Description src Source CIF to convert (can be gzipped) out Generated BinaryCIF output path -c Path to optional config file -f Path to optional filter file index.js [ -h ] [ -c CONFIG ] [ -f FILTER ] src out Config file Controls how certain columns will be encoded. This is a JSON array of instructions: interface EncodingStrategyHint { categoryName : string , columnName : string , encoding : 'pack' | 'rle' | 'delta' | 'delta-rle' , precision? : number } Identify a particular CIF columns by its name and override the encoding by Integer Packing, Run-Length Encoding, Delta Encoding, or Delta & Run-Length Encoding. You can optionally control the precision if dealing with float values. Filter file Specifies which categories and columns will be written. This is a plain text file, each line represents one entry. You can specify explicitly which categories or columns to include by adding category_name or category_name.field_name . You can also choose to ignore some categories or columns by adding !category_name or !category_name.field_name .","title":"Convert CIF to BinaryCIF"},{"location":"data-access-tools/convert-to-bcif/#convert-cif-to-binarycif","text":"BinaryCIF is an efficient, binary flavor of the CIF format. See specification and publication for further details. This script reads data in CIF format and converts it lossless to a BinaryCIF file that can be read by Mol* or other applications.","title":"Convert CIF to BinaryCIF"},{"location":"data-access-tools/convert-to-bcif/#example","text":"node lib/commonjs/cli/cif2bcif/index.js file.cif file.bcif","title":"Example"},{"location":"data-access-tools/convert-to-bcif/#usage","text":"Argument Description src Source CIF to convert (can be gzipped) out Generated BinaryCIF output path -c Path to optional config file -f Path to optional filter file index.js [ -h ] [ -c CONFIG ] [ -f FILTER ] src out","title":"Usage"},{"location":"data-access-tools/convert-to-bcif/#config-file","text":"Controls how certain columns will be encoded. This is a JSON array of instructions: interface EncodingStrategyHint { categoryName : string , columnName : string , encoding : 'pack' | 'rle' | 'delta' | 'delta-rle' , precision? : number } Identify a particular CIF columns by its name and override the encoding by Integer Packing, Run-Length Encoding, Delta Encoding, or Delta & Run-Length Encoding. You can optionally control the precision if dealing with float values.","title":"Config file"},{"location":"data-access-tools/convert-to-bcif/#filter-file","text":"Specifies which categories and columns will be written. This is a plain text file, each line represents one entry. You can specify explicitly which categories or columns to include by adding category_name or category_name.field_name . You can also choose to ignore some categories or columns by adding !category_name or !category_name.field_name .","title":"Filter file"},{"location":"data-access-tools/create-ccd-table/","text":"Create Table from CCD The Chemical Component Dictionary (CCD) is as an external reference file describing all residue and small molecule components found in PDB entries. The Protonation Variants Companion Dictionary (PVCD) enumerates protonation variants of canonical amino acids. This script bundles all chem_comp_bond information from the CCD and the PVCD into a single file for later use. Optionally, it can also generate a second output file that contains all chem_comp_atom information. Example node --max-old-space-size = 4096 lib/commonjs/cli/chem-comp-dict/create-table.js build/data/ccb.bcif -b Usage Argument Description out Generated file output path --forceDownload , -f Force download of CCD and PVCD --binary , -b Output as BinaryCIF --ccaOut , -a File output path of optionally generated chem_comp_atom create-table.js [ -h ] [ --forceDownload ] [ --binary ] [ --ccaOut CCAOUT ] out","title":"Create Table from CCD"},{"location":"data-access-tools/create-ccd-table/#create-table-from-ccd","text":"The Chemical Component Dictionary (CCD) is as an external reference file describing all residue and small molecule components found in PDB entries. The Protonation Variants Companion Dictionary (PVCD) enumerates protonation variants of canonical amino acids. This script bundles all chem_comp_bond information from the CCD and the PVCD into a single file for later use. Optionally, it can also generate a second output file that contains all chem_comp_atom information.","title":"Create Table from CCD"},{"location":"data-access-tools/create-ccd-table/#example","text":"node --max-old-space-size = 4096 lib/commonjs/cli/chem-comp-dict/create-table.js build/data/ccb.bcif -b","title":"Example"},{"location":"data-access-tools/create-ccd-table/#usage","text":"Argument Description out Generated file output path --forceDownload , -f Force download of CCD and PVCD --binary , -b Output as BinaryCIF --ccaOut , -a File output path of optionally generated chem_comp_atom create-table.js [ -h ] [ --forceDownload ] [ --binary ] [ --ccaOut CCAOUT ] out","title":"Usage"},{"location":"data-access-tools/extract-ccd-ions/","text":"Extract Ions from CCD The Chemical Component Dictionary (CCD) is as an external reference file describing all residue and small molecule components found in PDB entries. This script extracts all ions from the CCD and provides their names as TypeScript set. Example node --max-old-space-size = 4096 lib/commonjs/cli/chem-comp-dict/create-ions.js src/mol-model/structure/model/types/ions.ts Usage Argument Description out Generated file output path --forceDownload , -f Force download of CCD create-ions.js [ -h ] [ --forceDownload ] out","title":"Extract Ions from CCD"},{"location":"data-access-tools/extract-ccd-ions/#extract-ions-from-ccd","text":"The Chemical Component Dictionary (CCD) is as an external reference file describing all residue and small molecule components found in PDB entries. This script extracts all ions from the CCD and provides their names as TypeScript set.","title":"Extract Ions from CCD"},{"location":"data-access-tools/extract-ccd-ions/#example","text":"node --max-old-space-size = 4096 lib/commonjs/cli/chem-comp-dict/create-ions.js src/mol-model/structure/model/types/ions.ts","title":"Example"},{"location":"data-access-tools/extract-ccd-ions/#usage","text":"Argument Description out Generated file output path --forceDownload , -f Force download of CCD create-ions.js [ -h ] [ --forceDownload ] out","title":"Usage"},{"location":"data-access-tools/model-server/","text":"Model Server Provides access to molecular 1D, 2D, and 3D (sub-)structure models of molecules. Substructures are described by the mol-script (MolQL) language. It has the ability to include additional data to mmCIF \u201con the fly\u201d, e.g. integrate primary PDB archival data from Chemical Component Dictionary (CCD) , Protonation Variants Companion Dictionary (PVCD) and Biologically Interesting moleculeReference Dictionary (BIRD) . Example node lib/commonjs/servers/model/server --sourceMap pdb-bcif '/opt/data/bcif/${id}.bcif' Usage Argument Description --version , -v Show program's version number and exit. --cfg JSON config file path. If a property is not specified, cmd line param/OS variable/default value are used. --printCfg Print current config for validation and exit. --cfgTemplate Prints default JSON config template to be modified and exit. --apiPrefix Specify the prefix of the API, i.e. <host>/<apiPrefix>/<API queries> --defaultPort Specify the port the server is running on --cacheMaxSizeInBytes Read structures are cached, this specifies the cache size, 0 for off. --cacheEntryTimeoutMs Specify in ms how long to keep entries in cache. --requestTimeoutMs The maximum number of ms the server spends on a request. --queryTimeoutMs The maximum time the server dedicates to executing a query in ms. Does not include the time it takes to read and export the data. --shutdownTimeoutMinutes Server will shut down after this amount of minutes, 0 for off. --shutdownTimeoutVarianceMinutes Modifies the shutdown timer by +/- timeoutVarianceMinutes (to avoid multiple instances shutting at the same time) --maxQueryManyQueries Maximum number of queries allowed by the query-many at a time --defaultSource modifies which 'sourceMap' source to use by default --sourceMap Map id s for a source to a file path. Example: pdb-bcif '../../data/bcif/${id}.bcif' - JS expressions can be used inside ${} , e.g. ${id.substr(1, 2)}/${id}.mdb Can be specified multiple times. The SOURCE variable (e.g. pdb-bcif ) is arbitrary and depends on how you plan to use the server. Supported formats: cif, bcif, cif.gz, bcif.gz --sourceMapUrl Same as --sourceMap but for URL. --sourceMapUrl src url format Example: pdb-cif \"https://www.ebi.ac.uk/pdbe/entry-files/download/${id}_updated.cif\" cif Supported formats: cif, bcif, cif.gz, bcif.gz node lib/commonjs/servers/model/server [ -h ] [ -v ] [ --cfg CFG ] [ --printCfg ] [ --cfgTemplate ] [ --apiPrefix PREFIX ] [ --defaultPort PORT ] [ --cacheMaxSizeInBytes CACHE_SIZE ] [ --cacheEntryTimeoutMs CACHE_TIMEOUT ] [ --requestTimeoutMs REQUEST_TIMEOUT ] [ --queryTimeoutMs QUERY_TIMEOUT ] [ --shutdownTimeoutMinutes TIME ] [ --shutdownTimeoutVarianceMinutes VARIANCE ] [ --maxQueryManyQueries QUERY_MANY_LIMIT ] [ --defaultSource DEFAULT_SOURCE ] [ --sourceMap SOURCE PATH ] [ --sourceMapUrl SOURCE PATH SOURCE_MAP_FORMAT ] Production Use In production, it is required to use a service that will keep the server running, such as forever.js . Memory Issues Sometimes nodejs might run into problems with memory. This is usually resolved by adding the --max-old-space-size=8192 parameter. Preprocessor Example The preprocessor application allows addiing custom data to CIF files and/or convert CIF to BinaryCIF . node lib/commonjs/servers/model/preprocess Preprocessor Usage Argument Description --input , -i Input filename --outCIF , -oc Output CIF filename --outBCIF , -ob Output BinaryCIF filename --cfg , -c Config file path --folderIn , -fin Convert folder --folderOutCIF , -foc Convert folder text output --folderOutBCIF , -fob Convert folder binary output --folderNumProcesses , -fp Convert folder number processes Example cfg.json: { \"numProcesses\" : 1 , \"customProperties\" : { \"sources\" : [ \"wwpdb\" ], \"params\" : { \"wwPDB\" : { \"chemCompBondTablePath\" : \"./build/data/ccb.bcif\" } } } } Local Mode The server can be run in local/file based mode using node lib/commonjs/servers/model/query Custom Properties This feature is still in development. It is possible to provide property descriptors that transform data to internal representation and define how it should be exported into one or mode CIF categories. Examples of this are located in the mol-model-props module and are linked to the server in the config and servers/model/properties .","title":"Model Server"},{"location":"data-access-tools/model-server/#model-server","text":"Provides access to molecular 1D, 2D, and 3D (sub-)structure models of molecules. Substructures are described by the mol-script (MolQL) language. It has the ability to include additional data to mmCIF \u201con the fly\u201d, e.g. integrate primary PDB archival data from Chemical Component Dictionary (CCD) , Protonation Variants Companion Dictionary (PVCD) and Biologically Interesting moleculeReference Dictionary (BIRD) .","title":"Model Server"},{"location":"data-access-tools/model-server/#example","text":"node lib/commonjs/servers/model/server --sourceMap pdb-bcif '/opt/data/bcif/${id}.bcif'","title":"Example"},{"location":"data-access-tools/model-server/#usage","text":"Argument Description --version , -v Show program's version number and exit. --cfg JSON config file path. If a property is not specified, cmd line param/OS variable/default value are used. --printCfg Print current config for validation and exit. --cfgTemplate Prints default JSON config template to be modified and exit. --apiPrefix Specify the prefix of the API, i.e. <host>/<apiPrefix>/<API queries> --defaultPort Specify the port the server is running on --cacheMaxSizeInBytes Read structures are cached, this specifies the cache size, 0 for off. --cacheEntryTimeoutMs Specify in ms how long to keep entries in cache. --requestTimeoutMs The maximum number of ms the server spends on a request. --queryTimeoutMs The maximum time the server dedicates to executing a query in ms. Does not include the time it takes to read and export the data. --shutdownTimeoutMinutes Server will shut down after this amount of minutes, 0 for off. --shutdownTimeoutVarianceMinutes Modifies the shutdown timer by +/- timeoutVarianceMinutes (to avoid multiple instances shutting at the same time) --maxQueryManyQueries Maximum number of queries allowed by the query-many at a time --defaultSource modifies which 'sourceMap' source to use by default --sourceMap Map id s for a source to a file path. Example: pdb-bcif '../../data/bcif/${id}.bcif' - JS expressions can be used inside ${} , e.g. ${id.substr(1, 2)}/${id}.mdb Can be specified multiple times. The SOURCE variable (e.g. pdb-bcif ) is arbitrary and depends on how you plan to use the server. Supported formats: cif, bcif, cif.gz, bcif.gz --sourceMapUrl Same as --sourceMap but for URL. --sourceMapUrl src url format Example: pdb-cif \"https://www.ebi.ac.uk/pdbe/entry-files/download/${id}_updated.cif\" cif Supported formats: cif, bcif, cif.gz, bcif.gz node lib/commonjs/servers/model/server [ -h ] [ -v ] [ --cfg CFG ] [ --printCfg ] [ --cfgTemplate ] [ --apiPrefix PREFIX ] [ --defaultPort PORT ] [ --cacheMaxSizeInBytes CACHE_SIZE ] [ --cacheEntryTimeoutMs CACHE_TIMEOUT ] [ --requestTimeoutMs REQUEST_TIMEOUT ] [ --queryTimeoutMs QUERY_TIMEOUT ] [ --shutdownTimeoutMinutes TIME ] [ --shutdownTimeoutVarianceMinutes VARIANCE ] [ --maxQueryManyQueries QUERY_MANY_LIMIT ] [ --defaultSource DEFAULT_SOURCE ] [ --sourceMap SOURCE PATH ] [ --sourceMapUrl SOURCE PATH SOURCE_MAP_FORMAT ]","title":"Usage"},{"location":"data-access-tools/model-server/#production-use","text":"In production, it is required to use a service that will keep the server running, such as forever.js .","title":"Production Use"},{"location":"data-access-tools/model-server/#memory-issues","text":"Sometimes nodejs might run into problems with memory. This is usually resolved by adding the --max-old-space-size=8192 parameter.","title":"Memory Issues"},{"location":"data-access-tools/model-server/#preprocessor-example","text":"The preprocessor application allows addiing custom data to CIF files and/or convert CIF to BinaryCIF . node lib/commonjs/servers/model/preprocess","title":"Preprocessor Example"},{"location":"data-access-tools/model-server/#preprocessor-usage","text":"Argument Description --input , -i Input filename --outCIF , -oc Output CIF filename --outBCIF , -ob Output BinaryCIF filename --cfg , -c Config file path --folderIn , -fin Convert folder --folderOutCIF , -foc Convert folder text output --folderOutBCIF , -fob Convert folder binary output --folderNumProcesses , -fp Convert folder number processes Example cfg.json: { \"numProcesses\" : 1 , \"customProperties\" : { \"sources\" : [ \"wwpdb\" ], \"params\" : { \"wwPDB\" : { \"chemCompBondTablePath\" : \"./build/data/ccb.bcif\" } } } }","title":"Preprocessor Usage"},{"location":"data-access-tools/model-server/#local-mode","text":"The server can be run in local/file based mode using node lib/commonjs/servers/model/query","title":"Local Mode"},{"location":"data-access-tools/model-server/#custom-properties","text":"This feature is still in development. It is possible to provide property descriptors that transform data to internal representation and define how it should be exported into one or mode CIF categories. Examples of this are located in the mol-model-props module and are linked to the server in the config and servers/model/properties .","title":"Custom Properties"},{"location":"data-access-tools/plugin-state-server/","text":"Plugin State Server Provides a simple backend for online storing and sharing of Mol* sessions used by mol-plugin and mol-state modules. Example node lib/commonjs/servers/plugin-state --workding-folder ~ Usage Argument Description --working-folder Working folder path --port Server port. Alternatively, use ENV variable PORT. --api-prefix Server API prefix --max-states Maximum number of states to save node lib/commonjs/servers/plugin-state [ -h ] --working-folder WORKING_FOLDER [ --port PORT ] [ --api-prefix API_PREFIX ] [ --max-states MAX_STATES ]","title":"Plugin State Server"},{"location":"data-access-tools/plugin-state-server/#plugin-state-server","text":"Provides a simple backend for online storing and sharing of Mol* sessions used by mol-plugin and mol-state modules.","title":"Plugin State Server"},{"location":"data-access-tools/plugin-state-server/#example","text":"node lib/commonjs/servers/plugin-state --workding-folder ~","title":"Example"},{"location":"data-access-tools/plugin-state-server/#usage","text":"Argument Description --working-folder Working folder path --port Server port. Alternatively, use ENV variable PORT. --api-prefix Server API prefix --max-states Maximum number of states to save node lib/commonjs/servers/plugin-state [ -h ] --working-folder WORKING_FOLDER [ --port PORT ] [ --api-prefix API_PREFIX ] [ --max-states MAX_STATES ]","title":"Usage"},{"location":"data-access-tools/volume-server/","text":"Volume Server Provides near-instantaneous access to volumetric data including density maps (for instance, from X-ray crystallography or cryo-electron microscopy experiments), spatial distribution data, output from electrostatic calculations. It works by utilizing adaptive downsampling (similar to how Google Earth works). Example node lib/commonjs/servers/volume/server --idMap x-ray '/opt/data/xray/${id}.mdb' Usage Argument= Description --cfg JSON config file path. If a property is not specified, cmd line param/OS variable/default value are used. --printCfg Print current config for validation and exit. --cfgTemplate Prints default JSON config template to be modified and exit. --apiPrefix Specify the prefix of the API, i.e. <host>/<apiPrefix>/<API queries> --defaultPort Specify the port the server is running on --shutdownTimeoutMinutes Server will shut down after this amount of minutes, 0 for off. --shutdownTimeoutVarianceMinutes Modifies the shutdown timer by +/- timeoutVarianceMinutes (to avoid multiple instances shutting at the same time) --idMap Map id s for a type to a file path. Example: x-ray '../../data/mdb/xray/${id}-ccp4.mdb' - JS expressions can be used inside ${} , e.g. ${id.substr(1, 2)}/${id}.mdb - Can be specified multiple times. - The TYPE variable (e.g. x-ray ) is arbitrary and depends on how you plan to use the server. By default, Mol* Viewer uses x-ray and em , but any particular use case may vary. --maxRequestBlockCount Maximum number of blocks that could be read in 1 query. This is somewhat tied to the maxOutputSizeInVoxelCountByPrecisionLevel in that the &lt;maximum number of voxel&gt; = maxRequestBlockCount * &lt;block size&gt;^3 . The default block size is 96 which corresponds to 28,311,552 voxels with 32 max blocks. --maxFractionalBoxVolume The maximum fractional volume of the query box (to prevent queries that are too big). --maxOutputSizeInVoxelCountByPrecisionLevel What is the (approximate) maximum desired size in voxel count by precision level - Rule of thumb: &lt;response gzipped size&gt; in [&lt;voxel count&gt; / 8, &lt;voxel count&gt; / 4] . The maximum number of voxels is tied to maxRequestBlockCount. node lib/commonjs/servers/volume/server [ -h ] [ -v ] [ --cfg CFG ] [ --printCfg ] [ --cfgTemplate ] [ --apiPrefix PREFIX ] [ --defaultPort PORT ] [ --shutdownTimeoutMinutes TIME ] [ --shutdownTimeoutVarianceMinutes VARIANCE ] [ --idMap TYPE PATH ] [ --maxRequestBlockCount COUNT ] [ --maxFractionalBoxVolume VOLUME ] [ --maxOutputSizeInVoxelCountByPrecisionLevel LEVEL [ LEVEL ... ]]","title":"Volume Server"},{"location":"data-access-tools/volume-server/#volume-server","text":"Provides near-instantaneous access to volumetric data including density maps (for instance, from X-ray crystallography or cryo-electron microscopy experiments), spatial distribution data, output from electrostatic calculations. It works by utilizing adaptive downsampling (similar to how Google Earth works).","title":"Volume Server"},{"location":"data-access-tools/volume-server/#example","text":"node lib/commonjs/servers/volume/server --idMap x-ray '/opt/data/xray/${id}.mdb'","title":"Example"},{"location":"data-access-tools/volume-server/#usage","text":"Argument= Description --cfg JSON config file path. If a property is not specified, cmd line param/OS variable/default value are used. --printCfg Print current config for validation and exit. --cfgTemplate Prints default JSON config template to be modified and exit. --apiPrefix Specify the prefix of the API, i.e. <host>/<apiPrefix>/<API queries> --defaultPort Specify the port the server is running on --shutdownTimeoutMinutes Server will shut down after this amount of minutes, 0 for off. --shutdownTimeoutVarianceMinutes Modifies the shutdown timer by +/- timeoutVarianceMinutes (to avoid multiple instances shutting at the same time) --idMap Map id s for a type to a file path. Example: x-ray '../../data/mdb/xray/${id}-ccp4.mdb' - JS expressions can be used inside ${} , e.g. ${id.substr(1, 2)}/${id}.mdb - Can be specified multiple times. - The TYPE variable (e.g. x-ray ) is arbitrary and depends on how you plan to use the server. By default, Mol* Viewer uses x-ray and em , but any particular use case may vary. --maxRequestBlockCount Maximum number of blocks that could be read in 1 query. This is somewhat tied to the maxOutputSizeInVoxelCountByPrecisionLevel in that the &lt;maximum number of voxel&gt; = maxRequestBlockCount * &lt;block size&gt;^3 . The default block size is 96 which corresponds to 28,311,552 voxels with 32 max blocks. --maxFractionalBoxVolume The maximum fractional volume of the query box (to prevent queries that are too big). --maxOutputSizeInVoxelCountByPrecisionLevel What is the (approximate) maximum desired size in voxel count by precision level - Rule of thumb: &lt;response gzipped size&gt; in [&lt;voxel count&gt; / 8, &lt;voxel count&gt; / 4] . The maximum number of voxels is tied to maxRequestBlockCount. node lib/commonjs/servers/volume/server [ -h ] [ -v ] [ --cfg CFG ] [ --printCfg ] [ --cfgTemplate ] [ --apiPrefix PREFIX ] [ --defaultPort PORT ] [ --shutdownTimeoutMinutes TIME ] [ --shutdownTimeoutVarianceMinutes VARIANCE ] [ --idMap TYPE PATH ] [ --maxRequestBlockCount COUNT ] [ --maxFractionalBoxVolume VOLUME ] [ --maxOutputSizeInVoxelCountByPrecisionLevel LEVEL [ LEVEL ... ]]","title":"Usage"},{"location":"extensions/struct-conn/","text":"wwPDB StructConn extension wwPDB StructConn extension provides functionality to retrieve and visualize the connections from the STRUCT_CONN category in mmCIF files (such as hydrogen bonds, salt bridges, disulfide bridges). Refer to Documentation for Mol* wwPDB StructConn extension","title":"wwPDB StructConn"},{"location":"extensions/struct-conn/#wwpdb-structconn-extension","text":"wwPDB StructConn extension provides functionality to retrieve and visualize the connections from the STRUCT_CONN category in mmCIF files (such as hydrogen bonds, salt bridges, disulfide bridges). Refer to Documentation for Mol* wwPDB StructConn extension","title":"wwPDB StructConn extension"},{"location":"extensions/mvs/","text":"MolViewSpec Please see the standalone MolViewSpec documentation .","title":"MolViewSpec"},{"location":"extensions/mvs/#molviewspec","text":"Please see the standalone MolViewSpec documentation .","title":"MolViewSpec"},{"location":"transforms/custom-trajectory/","text":"Load Trajectory from a Custom Format This section shows a high level example for loading trajectory from custom data in specialized plugin instances. A more complete solution is available for example in form of the G3D format extension . Defining and Using a Custom Transformer import { StateTransformer } from 'molstar/lib/mol-state' ; const CreateTransformer = StateTransformer . builderFactory ( 'custom-namespace' ); export interface CustomTrajectoryData { // ... } export const TrajectoryFromCustomData = CreateTransformer ({ name : 'trajectory-from-custom-data' , display : 'Trajectory' , from : PluginStateObject.Root , to : PluginStateObject.Molecule.Trajectory , params : { data : PD.Value < CustomTrajectoryData > ( void 0 as any , { isHidden : true }), }, })({ apply ({ params }) { return Task . create ( 'Trajectory' , async ( ctx ) => { const models = await customParse ( params . data , ctx ); return new PluginStateObject . Molecule . Trajectory ( models , { label : 'Trajectory' , }); }); }, }); The customParse function can usually be implemented by modifying/extending an existing parser already available in Mol* . To use the transformer: const data : CustomTrajectoryData = await ( await fetch ( url )). json (); const trajectory = await plugin . build (). toRoot (). apply ( TrajectoryFromCustomData , { data }). commit (); // Create the representation await plugin . builders . structure . hierarchy . applyPreset ( trajectory , 'default' ); Using Mol* to Download the Data export const TrajectoryFromCustomData = CreateTransformer ({ name : 'trajectory-from-custom-data' , display : 'Trajectory' , from : PluginStateObject.Data.String , // or PluginStateObject.Data.Binary to : PluginStateObject.Molecule.Trajectory , })({ apply ({ a }) { return Task . create ( 'Trajectory' , async ( ctx ) => { const models = await customParse ( a . data , ctx ); return new PluginStateObject . Molecule . Trajectory ( models , { label : 'Trajectory' , }); }); }, }); ////////////// const data = await plugin . builders . data . download ({ url , isBinary }); const trajectory = await plugin . build (). to ( data ). apply ( TrajectoryFromCustomData , { data }). commit (); await plugin . builders . structure . hierarchy . applyPreset ( trajectory , 'default' );","title":"Load Trajectory from a Custom Format"},{"location":"transforms/custom-trajectory/#load-trajectory-from-a-custom-format","text":"This section shows a high level example for loading trajectory from custom data in specialized plugin instances. A more complete solution is available for example in form of the G3D format extension .","title":"Load Trajectory from a Custom Format"},{"location":"transforms/custom-trajectory/#defining-and-using-a-custom-transformer","text":"import { StateTransformer } from 'molstar/lib/mol-state' ; const CreateTransformer = StateTransformer . builderFactory ( 'custom-namespace' ); export interface CustomTrajectoryData { // ... } export const TrajectoryFromCustomData = CreateTransformer ({ name : 'trajectory-from-custom-data' , display : 'Trajectory' , from : PluginStateObject.Root , to : PluginStateObject.Molecule.Trajectory , params : { data : PD.Value < CustomTrajectoryData > ( void 0 as any , { isHidden : true }), }, })({ apply ({ params }) { return Task . create ( 'Trajectory' , async ( ctx ) => { const models = await customParse ( params . data , ctx ); return new PluginStateObject . Molecule . Trajectory ( models , { label : 'Trajectory' , }); }); }, }); The customParse function can usually be implemented by modifying/extending an existing parser already available in Mol* . To use the transformer: const data : CustomTrajectoryData = await ( await fetch ( url )). json (); const trajectory = await plugin . build (). toRoot (). apply ( TrajectoryFromCustomData , { data }). commit (); // Create the representation await plugin . builders . structure . hierarchy . applyPreset ( trajectory , 'default' );","title":"Defining and Using a Custom Transformer"},{"location":"transforms/custom-trajectory/#using-mol-to-download-the-data","text":"export const TrajectoryFromCustomData = CreateTransformer ({ name : 'trajectory-from-custom-data' , display : 'Trajectory' , from : PluginStateObject.Data.String , // or PluginStateObject.Data.Binary to : PluginStateObject.Molecule.Trajectory , })({ apply ({ a }) { return Task . create ( 'Trajectory' , async ( ctx ) => { const models = await customParse ( a . data , ctx ); return new PluginStateObject . Molecule . Trajectory ( models , { label : 'Trajectory' , }); }); }, }); ////////////// const data = await plugin . builders . data . download ({ url , isBinary }); const trajectory = await plugin . build (). to ( data ). apply ( TrajectoryFromCustomData , { data }). commit (); await plugin . builders . structure . hierarchy . applyPreset ( trajectory , 'default' );","title":"Using Mol* to Download the Data"}]}